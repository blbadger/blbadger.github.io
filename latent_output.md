## Input Generation II: Vectorization

This page is part II on generating inputs using deep learning models trained for image classification. For part I, follow [this link](https://blbadger.github.io/input-generation.html)

### Introduction to a Latent Space Output with Opposites

It is remarkable that deep learning models tasked with image classification are capable of producing coherent images representing a given output class. The task of image generation is far different than classification, but nevertheless recognizable images may be generated by optimizing the output for a given class.  In a previous section on this page, we also saw that images may be generated with a linear combination of two classes, which allowed us to transform a generated image of a husky into an image of a dalmatian.  

These observations lead to a natural idea: perhaps we can treat the output tensor as a latent space. A latent space, also known as an embedding, is informally one that captures meaningful information about the possible objects in that space.  More precisely, it is a manifold in which object similarity correlates with a distance metric on that manifold. 

We will consider the final 1000-dimensional fully connected layer activation of possible ImageNet categories as the output in question. At first glance it is not clear that this could be any kind of latent space: during training, each category is denoted by a one-hot vector in this space such that all possible categories are the same distance apart from each other.  This means that there is no prior information encoded in one output class versus another, which is exactly what one wants when training for classification without prior knowledge.

On the other hand, within this 1000-dimensional space we can view each class as a basis vector for this space and instead consider the possible vectors that exist in this space. A meaningful vector space of the outputs allows us to explore interesting questions by simply converting each question into a vector arithmetic operation.  

On a memorable episode of the popular comedy 'Seinfeld', the character George decides to do the opposite of what he would normally do with appropriately comedic results.  But one might wonder: what is the opposite?  For a number of ideas, there seems to be a natural opposite (light and dark, open and closed) but for others ideas or objects it is more difficult to identify an opposite: for example, what is the opposite of a mountian?  One might say a valley, but this is far from the only option.  Likewise, objects like a tree and actions like walking do not have clear opposites.

Fortunately, finding a meaningful opposite using our image-generating deep learning models will not be difficult if the output is indeed a latent space.  UWe want to perform gradient descent on the input $a$ in order to minimize the activation of the output category of interest $O_i$, meaning that our loss function $J$ is

$$
J(O(a, \theta)) = O_i(a, \theta)
$$

and the gradient we want is the gradient of this loss with respect to the input, which is

$$
g = \nabla_a (O_i(a, \theta))
$$

The above formula can be implemented by simply assigning the loss to be the output of the output category as minimization is equivalent to maximization of a negative value.

```python
def layer_gradient(model, input_tensor, desired_output):
    ...
    input_tensor.requires_grad = True
    output = model(input_tensor)
    loss = output[0][int(desired_output)] # minimize the output class activation
    loss.backward()
    gradient = input_tensor.grad
    return gradient
```

and as before this gradient $g$ is used to perform gradient descent on the input, but now we will minimize rather than maximize the category of interest.

$$
a_{n+1} = a_n - \epsilon *  g
$$

In geometric terms, this procedure is equivalent to the process of moving in the input space in a direction that corresponds with moving in the output space towards the negative axis of the dimension of the output category as far as possible.  

At first consideration, this procedure might not seem to be likely to yield any meaningful input $a_n$, as there is no guarantee that moving away from some class would not yield an input that is a mix of many different objects.  And indeed many generated opposite images are apparently a mix of a number of objects, for example this 'Piano' opposite that appears to be the image of a few different insects, or the opposite of 'Bonnet' that appears to be a mousetrap spring on fire.

![opposites]({{https://blbadger.github.io}}/neural_networks/googlenet_opposites_mix.png)

Despite it being unlikely that any of the 1000 ImageNet categories would have only one opposite, we can find the category of the image as classified by our model of choice (GoogleNet) by finding which element of the tensor of the model's output $O(a_n, \theta)$, denoted `output`, has the maximum activation.

```python
predicted = int(torch.argmax(output))
```

Now we can label each generated image according to which ImageNet category it most activates using a model of choice, here GoogleNet to be consistent with the image generation.  The following video shows the generation of an input $a$ that minimizes the GoogleNet activation for ImageNet class 55: Green Snake (red dot in the scatterplot to the right). Once again, two octaves with Gaussian convolutions are applied during gradient descent.

{% include youtube.html id='czayyaAi1cw' %}

Notice how a number of different categories have been maximized, and how the image appears to be a combination of different parts (an axolotl's gills with the feet and scales of a crocodile are perhaps the two most obvious).  Some objects have more coherent, even reasonable opposites: toilet paper is soft, flat, and waivy whereas syringes are thing and pointy.  

![opposites]({{https://blbadger.github.io}}/neural_networks/googlenet_opposites.png)

Dogs are perhaps the most interesting image category for this procedure nearly every ImageNet dog class has a coherent opposite that is also a dog, and the opposites generated seem to be logically motivated: observe how the opposites for large, long-haired dogs with no visible ears are small, thin, and perky-eared breeds.

![dog opposites]({{https://blbadger.github.io}}/neural_networks/googlenet_shaggy_opposites.png)

and likewise the opposites of a dog with longer fur and a pointed face (border collie) is one with short fur and squashed face (bloodhound), and the opposite of an image of a small dog with pointed ears (Ibizan hound) is a large dog with droopy ears (Tibetan Mastiff). Observe that opposites are rarely commutative: here we see a close but not quite commutative relation, where the opposite of an Ibizan is a Mastiff but the opposite of a Mastiff is a Terrier.  In general opposites are further from being commutative than this example.

![dog opposites]({{https://blbadger.github.io}}/neural_networks/googlenet_nonshaggy_opposites.png)

It is fascinating to see the generated images for the opposites of other animal classes.  

![animal opposites]({{https://blbadger.github.io}}/neural_networks/googlenet_animal_opposites.png)

The opposites of snakes are curiously usually lizards (including crocodiles) or amphibians (including axolotls) and the opposites of a number of birds are species of fish.  Opposites to all ImageNet class images according to GoogleNet may be found by following [this link](https://drive.google.com/drive/folders/1nE9X0PkG51RIL5euIHwOHfuV5OWWQm0i?usp=sharing). 

### Dog Transfiguration

We can view the difference between a Husky and a Dalmatian according to some deep learning model by observing what changes as our target class shifts from 'Husky' to 'Dalmatian', all using a picture of a dalmatian as an input.  To do this we need to be able to gradually shift the target from the 'Husky' class (which is $\widehat y_{250}$ in ImageNet) to the 'Dalmatian' class, corresponding to $\widehat y_{251}$.  This can be accomplished by assigning the loss $J_n(0(a, \theta))$ $n=q$ maximum interations, at iteration number $n$ as follows:

$$
J_n(O(a, \theta)) \\
= \left(c - \widehat y_{250} * \frac{q-n}{q} \right) + \left(c - \widehat y_{251} * \frac{n}{q} \right) 
$$

and to the sum on the right we can add an $L^1$ regularizer if desired, applied to either the input directly or the output.  Applied to the input, the regularizer is as follows:

$$
L_1 (a) = \sum_i \lvert a_i \rvert
$$

Using this method, we go from $(\widehat y_{250}, \widehat y_{251}) = (c, 0)$ to $(\widehat y_{250}, \widehat y_{251}) = (0, c)$ as $n \to q$.  The intuition behind this approach is that $(\widehat y_{250}, \widehat y_{251}) = (c/2, c/2)$ or any other linear combination of $c$ should provide a mix of characteristics between target classes. 

{% include youtube.html id='1bdpG1caKMk' %}

Using InceptionV3 as our model for this experiment, we have  we see that this is indeed the case: observe how the fluffy husky tail becomes thin, dark spots form on the fur, and the eye color darkens as $n$ increases.

{% include youtube.html id='PBssSJoLOhU' %}

### Vector Addition and Subtraction

We have so far seen that it is possible to generate recognizable images $a'$ that represent the opposites of some original input $a$, where the gradient descent procedure makes the input $a' = -a$ according to how the model views each input.  Likewise it has been observed that linear combinations of the output corresponding to two breeds of dog yield recognizable images where $a' = ba_0 + ca_1$ for some constant $d$ such that $b + c = d$.

We can explore other vector operations.  Vector addition is the process of adding the component vectors in a space, and may be thought of as resulting in a vector that contains some of the qualities of both operands. 

![resnet_addition]({{https://blbadger.github.io}}/neural_networks/vectorized_resnet_1.png)

![resnet_addition]({{https://blbadger.github.io}}/neural_networks/vectorized_resnet_2.png)


### Feature Latent Space

Suppose one were to want to understand which of the ImageNet categories were more or less similar to another.  For example, is an image of a cat more similar to a fox or a wolf?  Specifically we want this question answered with abstract ideas like facial and tail structure, rather than some simple metric like color alone.

This question is not at all easy to address.  We seek a metric that will determine how far ImageNet category is from every other category, but the usual metrics one can place on an image will not be sufficient.  Perhaps the simplest way to get this metric is to take the average image for each category (by averaging the values of all images of one category pixel per pixel) and measure the $L^2$ or $L^1$ distance between each image.  This is almost certain to fail in our case because there is no guarantee that such a distance would correspond to higher-level characteristics rather than lower-level characteristics like color or hue.

Instead we want a measurement that corresponds to more abstract quantities, like the presence of eyes, number of legs, or roundness of an object in an image. We could use those three traits alone, and make a three-dimensional representation called an embedding consisting of points in space where the basis of the vector space is precisely the values attached to each of these characteristics.  For example, if we have some object where `[eyes, legs, roundness] = [4, 10, 0.2]` we would likely have some kind of insect, whereas the point `[-10, -2, 10]` would most likely be an inanimate object like a beach ball.

Happily for us, deep learning models are capable of observing high-level characteristics of an image.  We have seen that [feature maps](https://blbadger.github.io/feature-visualization.html) of certain hidden layers of these models tend to be activated by distinctive patterns, meaning that we can use the total or average activation of a feature map as one of our basis vectors.

Somewhat arbitrarily, let's choose two features from GoogleNet's layer 5a as our basis vectors.  For reference, here are the maps for the features of interest (meaning that the following images were found to maximally activate the features via gradient descent):

![resnet_addition]({{https://blbadger.github.io}}/neural_networks/googlenet_features_latent.png)

Feature 0 seems to respond to a brightly colored bird-like pattern whereas feature 4 is maximally activated by something resembling a snake's head and scales.  We can observe the activation of these layers for GoogleNet-generated images representing each ImageNet class in order to get an idea of which categories these layers score as more or less similar from each other.  The following code allows us to plot

```
x, y, labels_arr = [], [], []
for i, image in enumerate(images):
    label = image[1]
    image = image[0].reshape(1, 3, 299, 299).to(device)
    output = network(image)
    x.append(float(torch.mean(output[0, 0, :, :])))
    y.append(float(torch.mean(output[0, 1, :, :])))
    i = 11
    while label[i] not in ',.':
        i += 1
    labels_arr.append(label[11:i])
    
plt.figure(figsize=(18, 18))
plt.scatter(x, y)
for i, label in enumerate(labels_arr):
    plt.annotate(label, (x[i], y[i]))
plt.show()
plt.close()
```

this yields

![googlenet embedding]({{https://blbadger.github.io}}/neural_networks/googlenet_5a_04_embedding.png)


When we consider the distribution of average activations of both features,

![googlenet embedding]({{https://blbadger.github.io}}/neural_networks/googlenet_5a_distribution.png)

it is apparent that both are approximately normally distributed.  This is beceause each convolutional layer in the Pytorch implementation of GoogleNet is followed by a Batch Normalization layer, which enforces a normal distribution on the outputs of those layers.  We can remove this batch normalization from the final layer by setting the Batch Norm layer weights to the multiplicative identity 1 and the bias to the additive identity 0.

```python
def blank_batchnorm(layer):
    layer.reset_parameters()
    layer.eval()
    with torch.no_grad():
        layer.weight.fill_(1.0)
        layer.bias.zero_()
    return
```

This can be enforced in our model as follows:

```python
class NewGoogleNet(nn.Module):

    def __init__(self, model):
        super().__init__()
        self.model = model
        self.model.inception5a.branch1.bn.apply(blank_batchnorm) # only this is necessary for features 0 and 4
        self.model.inception5a.branch2[1].bn.apply(blank_batchnorm)
        self.model.inception5a.branch3[1].bn.apply(blank_batchnorm)
```

![googlenet embedding]({{https://blbadger.github.io}}/neural_networks/googlenet_5a_04_embedding_noBN.png)

and we can see that indeed the distributions of activations for both features are slightly less well-approximated by a Gaussian distribution.

![googlenet embedding]({{https://blbadger.github.io}}/neural_networks/googlenet_5a_distribution_nobn.png)

### Output Latent Space

The embeddings of ImageNet examples for two features of one layer of GoogleNet were explored in the previous section.  But these embeddings are of limited use, because they represent only a very small portion of the information that the model possesses with regards to the input images, as there are many more features in that layer and many more layers in the model.  Each of the features and layers are important to the final classification prediction, and moreover these layers and features are formed by non-linear functions such that the features and layers are non-additive.

All this is to say that although the embeddings of the output categories using feature activation as the basis space is somewhat useful, it is by no means comprehensive.  Another approach may be in order in which the entire model is used, rather than a few features.

One method to address this is to perform an embedding of the output with respect to the model.  The reasoning here is that our trained GoogleNet model with parameters $\theta$ may be viewed as a (very complicated) function $O$ that maps input images $a$ to an output $y$, which is a 1000-dimensional vector where the element of index $n$ denoted by $y_n$.

$$
y = O(a, \theta)
$$

Now if we use real images from some category, there is no guarantee that $v$ will be unchanged and it is unclear which $v$ best respresents the image category.  Instead we can use an image $a'$ generated to maximize the output category of interest (for more information on this, see [here](https://blbadger.github.io/input-generation.html)) as an approximation of the input that will most resemble the output category of interest $\widehat y_n = O_n(a, theta)$.

$$
a' = \mathrm{arg} \; \underset{a}{\mathrm{max}} O_n(a, \theta)
$$

Using these representative inputs $a'$ applied to $O$, we can find the coordinates of all model outputs $y_n \in \Bbb R^1000$.  This means that we can find the coordinates of the representative input $a'$ in the 1000-dimensional output space. 

As spaces with more than two or three dimensions are hard to visualize, we can perform a dimensionality reduction method for visualization, and here we will find a function $f$ to take $f: y_n \in \Bbb R^1000 \to z_n \in \Bbb R^2$.  We shall employ principle component analysis, which is defined as the function $f(y)$ that produces the embedding $z$ such that a decoding function $g$ such that $x \approx g(f(y))$, where $g(y) = Dy$ and $D \in \Bbb R^{1000x2}$.  Therefore PCA is defined as the encoding function $f$ that minimized the distance of the encoded value $z$ from the original value $y$ subjected to the constraint that the decoding process be a matrix multiplication.  To further simplify things, $D$ is constrained to have linearly independent columns of unit norm.  The minimization procedure may be accomplished using eigendecomposition and does not requre gradient descent.

When we find the coordinates of $y_n$ for all $n$ ImageNet categories using GoogleNet and then map these points using the first two principle components

![googlenet embedding]({{https://blbadger.github.io}}/neural_networks/googlenet_output_embedding.png)

but the result is quite underwhelming.  There does not appear to be any noticable pattern in how the categories are arranged along these components, which when we investigate the percentage of variance explained is not surprising: these components account for only $1.8$ and $1.6$ percent of the variance which means that they are nearly meaningless as they capture very little of the original distribution.

Why is this the case?  The primary failure lies in PCA's expectation of a linear space, in which transformations $f$ are additive and scaling

$$
af(x + y) = f(ax) + f(ay)
$$

and where in particular the intuitive metric of distance stands.  But we have already seen that the output space $y = O(a', \theta)$ does not obey the familiar requirements for a linear metric space because $m(a, b) \neq m(b, a)$, or in words because distance measurements are not commutative. We therefore can expect the output space $y$ to be nonlinear and to be poorly approximated by any matrix multiplication-based method like PCA, as these are composed of linear operations.

But happily there is a straightforward way to determine which ImageNet categories are more or less similar than each other: we can simply take the output vector $y = O(a', \theta)$ and observe the magnitude of the components of this vector.






