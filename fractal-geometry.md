## Fractal Geometry

Images of dynamical systems, as seen in other pages of [this site](https://blbadger.github.io/), are often described as fractals.  This section explores the meaning of this term, its origins, and deep connections between fractals and nonlinear dynamics and other fields.

### Origin and Cantor's set

The term *Fractal* was chosen by Mandelbrot (after the Latin *Fractus*) to signify irregular (after a sense), fragmented objects.  These often but do not necessarily have a fractional scaling dimension, and the surface of these objects is non-differentiable.  Spectacular examples of fractals such as the Julia and Mandelbrot sets are often brought to mind when one thinks of fractals, but they are far older and richer than these examples alone.  Nearly a century before the word fractal had been invented, the foundations for this branch of math were established and are here roughly detailed.

In the late 19th century Cantor founded set theory, a study of abstract collections of objects and the relations between these collections.  Other pages in this website make use of set theory, and for a good background on the subject see "Naive set theory" by Halmos.  From set theory, we find fascinating conclusions that lay a foundation for fractal geometry, so to understand the latter it is best to examine a few key aspects of the former. 

Surprising results abound in set theory, but one of the most relevant here is that pertaining to measurment.  Firstly, not all infinities are equal: there are as many integers as there are rational numbers (an infinite amount of each) but there are far more real numbers than either.  The elegant diagonal proof for this is worth viewing elsewhere, as it reappears again in other forms (in Turing's computability theories, for example). 

A particularly interesting set is known as the middle thirds Cantor set $C$.  This set will be considered in some detail because it illustrates many of the most important aspects of fractals but is relatively simple, existing on a line.  $C$ is made as follows: take the closed interval on the reals $[0, 1]$ and remove from this an open interval of the middle third, that is, $[0, 1] - (1/3, 2/3)$.  

![cantor]({{https://blbadger.github.io}}/fractals/cantor000.png)

Now repeat this process for each remaining closed intervals,

![cantor]({{https://blbadger.github.io}}/fractals/cantor001.png)

and again

![cantor]({{https://blbadger.github.io}}/fractals/cantor002.png)


![cantor]({{https://blbadger.github.io}}/fractals/cantor003.png)

and so on ad infinitum.  $C$ is the set of numbers that remains after an infinite number of these steps.  This set is remarkable: after n steps of removing the inner third, $(\frac{2}{3})^n$ total length remains.  Therefore $C$ has $0$ total length: $(2/3)^n \to 0 \; as \; n \to \infty$.  If it has $0$ length, does $C$ have any points? It does indeed, just as many points as the original closed interval $[1,0]$!  The set is totally disconnected (no point touches any other point) and perfect (every point is a limit of another set of points in $C$).

This set can be drawn with Turtle, a Python programming library that was designed to help teach programming in a visual way.  It turns out to be quite capable of intricate fractal drawings as well.

```python
from turtle import *
import turtle

def cantor_set(size, recursive_steps):
	if recursive_steps > 0:
		cantor_set(size/3, recursive_steps-1)

		turtle.pu(), turtle.forward(size), turtle.pd()
		cantor_set(size/3, recursive_steps-1)

	else:
		turtle.color('red'), turtle.forward(size)
		turtle.pu(), turtle.forward(size), turtle.pd()
		turtle.color('blue'), turtle.forward(size)


for i in range(300):
	turtle.hideturtle()
	turtle.speed(0), turtle.delay(0)
	turtle.pensize(4)
	turtle.setup (width=1900, height=1080, startx=0, starty=0)
	turtle.pu(), turtle.goto(-800, 0), turtle.pd()

	cantor_set(500 * (2**(i/30)), 4 + i // 30)
	turtle_screen = turtle.getscreen()
	turtle_screen.getcanvas().postscript(file="cantor_set{0:03d}.eps".format(i))
	turtle.reset()
```

The `.eps` files generated by this program are vector images, and to make a video conversion to a fixed size .png or .jpg type file is useful.  Fortunately the Python Image Library has the wonderful ability to detect and reformat all kinds of image types!  I used the following program to convert `.eps` to `.png` files:

```python
from PIL import Image
import os

 # insert path here
path = '/home/bbadger/Desktop/' 

files = os.listdir(path)

for i in range(0, len(files)):
	string = str(i)
	while len(string) < 3:
		string = '0' + string
	try:
		eps_image = Image.open('cantor_set' + string + '.eps') # input names here
	except:
		break
	eps_image.load(scale=2)   
	eps_image.save('cantor{0:03d}.png'.format(i)) # output names here
```
After compiling these `.png` images into an mp4 using ffmpeg in bash

```bash
(base) bbadger@bbadger:~$ ffmpeg -f image2 -r 30 -pattern_type glob -i '*.png' cantor_zoom.mp4
```

the video can be viewed and edited.  Here it is as a .gif (ffmpeg can convert directly into gifs simply by changing the extension name to `cantor_zoom.gif`, but these are uncompressed and can be quite large files)

![cantor zoom]({{https://blbadger.github.io}}/fractals/cantor_zoom1.gif)

As the number of recursive calls increases, the Cantor set becomes invisible.  This should not come as a surprise, being that it is of measure $0$ as $n \to \infty$.  Thus in order to obtain a viewable map with more recursive steps, vertical lines are used to denote the position of each point in the set.  The following program accomplishes this by drawing alternating red and blue vertical lines at the start of where each set interval (at any given step) begins and so is only accurate with a relatively large value for the starting number of recursions (>4).  A black background is added for clarity, and once again the number of recursive steps increases with scale to maintain resolution.

```python
from turtle import *
import turtle

def cantor_set(size, recursive_steps, width, height):
	if recursive_steps > 0:
		# only proceed if not out of canvas bounds
		if turtle.pos()[0] < width:
			cantor_set(size/3, recursive_steps-1, width, height)
		turtle.pu()
		turtle.forward(size)
		turtle.pd()

		# only proceed if not out of canvas bounds
		if turtle.pos()[0] < width:
			cantor_set(size/3, recursive_steps-1, width, height)

	else:
		turtle.color('blue')
		turtle.left(90)
		turtle.forward(height), turtle.right(180), turtle.forward(height)
		turtle.left(90)
		turtle.pu(), turtle.forward(size), turtle.pd()
		turtle.color('red')
		turtle.left(90)
		turtle.forward(height), turtle.right(180), turtle.forward(height)
		turtle.left(90)


def background_square(width, height, color):
	turtle.goto(-width//2 - 1, -height//2 - 1)
	turtle.fillcolor(color)

	# draw a background rectangle and fill with desired color
	turtle.begin_fill()
	turtle.forward(width+2), turtle.left(90)
	turtle.forward(height+2), turtle.left(90)
	turtle.forward(width+2), turtle.left(90)
	turtle.forward(height+2), turtle.left(90)
	turtle.end_fill()


for i in range(300):
	turtle.hideturtle()
	turtle.bgcolor('black'), turtle.color('black')
	turtle.speed(0), turtle.delay(0)
	turtle.pensize(0.001)

	w, h = 1900, 1080 # width and height
	turtle.setup (width=w, height=h, startx=0, starty=0)
	background_square(w, h, 'black')
	
	turtle.pu()
	turtle.goto(-900, -540)
	turtle.pd()

	cantor_set(500*2**(i/60), 5 + i//90, w, h)
	turtle_screen = turtle.getscreen()
	turtle_screen.getcanvas().postscript(file="cantor_set{0:03d}.eps".format(i))
	turtle.reset()
```

Or in a more object-oriented approach:

```python
from turtle import *
import turtle

class Cantor_drawing:

	def __init__(self, size, recursive_steps, width, height, color):
		self.size = size
		self.recursive_steps = recursive_steps
		self.width = width
		self.height = height
		self.color = color

	def cantor_set(self):
		if self.recursive_steps > 0:
			# only proceed if not out of canvas bounds
			if turtle.pos()[0] < self.width:
				self.size /= 3
				self.recursive_steps -= 1
				Cantor_drawing.cantor_set(self)
				self.size *= 3
				self.recursive_steps += 1
			turtle.pu()
			turtle.forward(self.size)
			turtle.pd()

			# only proceed if not out of canvas bounds
			if turtle.pos()[0] < self.width:
				self.size /= 3
				self.recursive_steps -= 1
				Cantor_drawing.cantor_set(self)
				self.size *= 3
				self.recursive_steps += 1

		else:
			turtle.color('blue')
			turtle.left(90)
			turtle.forward(self.height), turtle.right(180), turtle.forward(self.height)
			turtle.left(90)
			turtle.pu(), turtle.forward(self.size), turtle.pd()
			turtle.color('red')
			turtle.left(90)
			turtle.forward(self.height), turtle.right(180), turtle.forward(self.height)
			turtle.left(90)


	def background_square(self):
		turtle.goto(-self.width//2 - 1, -self.height//2 - 1)
		turtle.fillcolor(self.color)

		# draw a background rectangle and fill with desired color
		turtle.begin_fill()
		turtle.forward(self.width+2), turtle.left(90)
		turtle.forward(self.height+2), turtle.left(90)
		turtle.forward(self.width+2), turtle.left(90)
		turtle.forward(self.height+2), turtle.left(90)
		turtle.end_fill()
		turtle.forward(100)


for i in range(300):
	turtle.hideturtle()
	turtle.bgcolor('black'), turtle.color('black')
	turtle.speed(0), turtle.delay(0)
	turtle.pensize(0.001)

	w, h = 1900, 1080 # width and height
	turtle.setup (width=w, height=h, startx=0, starty=0)
	turtle.pu()
	turtle.goto(-900, -540)
	turtle.pd()
	Cantor_drawing(500, 5, w, h, 'black').background_square()
	Cantor_drawing(500 * (2**(i/30)), 5 + i // 30, w, h, 'black').cantor_set()

	turtle_screen = turtle.getscreen()
	turtle_screen.getcanvas().postscript(file="cantor_set{0:03d}.eps".format(i))
	turtle.reset()

```

which results in 

![cantor zoom]({{https://blbadger.github.io}}/fractals/cantor_zoom_vertical.gif)

Now this is one particular example of a Cantor set, but there are others: one could remove middle halves instead of thirds etc.  The general definition of a Cantor set is any set that is closed, bounded, totally disconnected, and perfect.  The general Cantor set $C$ is a common occurence in nonlinear maps.  The following arrangement of stable versus unstable locations for the [Clifford attractor](/clifford-boundary.md) is a good example of an irregular Cantor set

![clifford]({{https://blbadger.github.io}}clifford_attractor/clifford_bound_zoom1.gif)

as is the [henon map](/henon-map.md), although here the pattern of $C$ is regular.

### Space filling curves

What is the dimension of the Cantor set?  Finite collections of points are of dimension $0$, whereas lines are of dimension $1$.  $C$ is totally disconnected and therefore would seem to be $0$ dimensional, and yet it is an infinite collection of points that are bounded to a specific region.  Thus $C$ has characteristics of both zero and one dimensions.  Do any other curves also exhibit properties of multiple dimensions?

One can defined fractals as objects that exhibit properties of multiple dimensions, and in that respect every image on this page is an example of a curve that answers this question. But before exploring those, it may be useful to view some extreme cases: curves (1-dimensinal objects) that fill space (2 dimensions).  One of the first such curves to be discovered to do this by Peano in the late 19th century can be described in python as follows

```python
ls = [90, -90, -90, -90, 90, 90, 90, -90, 0]
def peano_curve(size, recursive_steps, ls):
	if recursive_steps > 0:
		for i in range(len(ls)):
			peano_curve(size, recursive_steps-1, [i for i in ls])
			turtle.left(ls[i])
	else:
		turtle.forward(size)
```
where `recursive_steps` goes to infinity.  To understand how this fills space, observe the base case:

![peano 1]({{https://blbadger.github.io}}/fractals/peano_curve1_1.gif)

and the first recursive step, where each line segment of the curve above is replaced with a smaller version of the whole curve:

![peano 1]({{https://blbadger.github.io}}/fractals/peano_curve1_2.gif)

After a few more recursive steps (only 5 in total!) , the present resolution is no longer able to differentiate between one line and another and we have achieved something close to a space-filling curve.

![peano 1]({{https://blbadger.github.io}}/fractals/peano_surface.gif)

This curve fills space but crosses over itself.  The following is another space filling curve from Peano that does not self-cross but is more difficult to draw.  The L -system, named after its discoverer Lindenmayer, is a very useful system for characterizing the generation of more complex recursive structures.  For a good overview of this system complete with examples, see [here](http://paulbourke.net/fractals/lsys/).  The Peano curve may be defined in the L-system by the sequences `X = 'XFYFX+F+YFXFY-F-XFYFX', Y = 'YFXFY-F-XFYFX+F+YFXFY'` where X and Y are separate recursive sequences, '+' signifies a turn left by 90 degrees, '-' a turn right 90 degrees, and 'F' signifies a movement forward.  This can be implemented in python by interpreting each L-system element separately as follows:

```python
def peano_curve(size, steps, orientation):
	X = 'XFYFX+F+YFXFY-F-XFYFX'
	Y = 'YFXFY-F-XFYFX+F+YFXFY'
	l = r = 90

	if steps == 0:
		return

	if orientation > 0:
		for i in X:
			if i == 'X':
				peano_curve(size, steps-1, orientation)
			elif i == 'Y':
				peano_curve(size, steps-1, -orientation)
			elif i == '+':
				turtle.left(90)
			elif i == '-':
				turtle.right(90)
			else:
				turtle.forward(size)

	else:
		for i in Y:
			if i == 'X':
				peano_curve(size, steps-1, -orientation)
			elif i == 'Y':
				peano_curve(size, steps-1, orientation)
			elif i == '+':
				turtle.left(90)
			elif i == '-':
				turtle.right(90)
			else:
				turtle.forward(size)
```   

The base case 

![peano 2]({{https://blbadger.github.io}}/fractals/peano_2_1.png)

and first recursion 

![peano 2]({{https://blbadger.github.io}}/fractals/peano_2_2.png)

at the fifth recursion level, 

![peano 2]({{https://blbadger.github.io}}/fractals/peano_surface2.gif)

As is the case in the first Peano curve, the true space-filling curve is the result of an infinite number of recursive steps.  This means that the curve is also infinitely long, as the length grows upon each recursive step.  Infinite length is a prerequisite for any space-filling curve.

Note that both of these curves are nowhere-differentiable: pick any point on the curve, and it is an angle (a 90 degree angle to be precise) and as angles are non-differentiable, the curve is non-differentiable.  

These curves map a line of infinite length to a surface, and the mapping is continuous.  But importantly, this mapping is not one-to-one (injective): multiple points on the starting line end up at the same spots in the final surface. In fact no injective mapping exists between one and two dimensions exists, and a geometric proof of this in the second Peano curve is as follows: observe the point at the upper right corner of the curve $p_1$ and the point directly below it $p_1$ to be $p_2$. Upon each recursion $r$, the distance between these points is divided by 3 such that 

$$
d(p_1, p_2)_{r+1} = \frac{d(p_1, p_2)_{r}}{3} \\ 
\; \\
\frac{1}{3^n} \to 0 \; as \; \; n \to \infty \\
\; \\
d(p_1, p_2) \to 0 \; as \; \; r \to \infty
$$

Now the true Peano curves are infinitely recursive, therefore this the distance between these points is 0 and therefore $p_1$ and $p_2$ map to the same point in two dimensional space, making the Peano curve a non-injective mapping.

Imagine moving along the surface created by either peano curve. An arbitrarily small movement in one direction along this surface does not necessarily lead to a small movement along the curve itself.  This means that these Indeed it can be shown that any mapping from two to one dimensions (which could be considered to be equivalent to the definition of a space filling curve) is nowhere-continuous if the mapping is one-to-one and onto.  For some interesting repercussions of this on neural networks, see [here](/neural-networks.md).


### Fractals: objects of multiple dimensions

The Koch curve may be drawn as follows

```python
ls = [60, -120, 60, 0]
def koch_curve(size, recursive_steps, ls):
	if recursive_steps > 0:
		for i in range(len(ls)):
			koch_curve(size, recursive_steps-1, [i for i in ls])
			turtle.left(ls[i])

	else:
		turtle.forward(size)
```

The curve starts as

![koch]({{https://blbadger.github.io}}/fractals/koch_snowflake1.png)

and at each recursion, each line segment is divided into parts that resemble the whole. At the 2nd,

![koch]({{https://blbadger.github.io}}/fractals/koch_snowflake2.png)

3rd,

![koch]({{https://blbadger.github.io}}/fractals/koch_snowflake3.png)

and 6th recursion:

![koch]({{https://blbadger.github.io}}/fractals/koch_snowflake6.png)

Now this curve evidently does not cover the plane like the Peano curves. But the curve does seem 'fuzzy', and that it might cover at least part of the plane. In this respect, it seems to be partway between dimensions. Is this the case?

A better understanding comes from the similarity dimension, which is equivalent to the Hausdorff dimension for the following self-similar objects. First note that Euclidean objects like a point, line, or surface have the same topological dimension as their similarity dimension: a point cannot be subdivided ($n^0 = 1$), a line of length n can be subdivided into $n^1 = n$ pieces, and a surface square of length n can be subdivided into $n^2$ pieces.  Now note that the Koch curve may be subdivided into four equal pieces, and that these pieces are $1/3$ the length of the total curve.  It's similarity dimension is therefore

$$
D = \frac{log \; N}{log \; (1/r)} \\
\; \\
D = \frac{log \; 4}{log \; 3} \approx 1.2618
$$

Now consider the following curve, known as the quadric Koch curve:

```python
ls = [90, -90, -90, 0, 90, 90, -90, 0]
def quadric_koch_curve(size, recursive_steps, ls):
	if recursive_steps > 0:
		for i in range(len(ls)):
			quadric_koch_curve(size, recursive_steps-1, ls)
			turtle.left(ls[i])

	else:
		turtle.forward(size)
```
The curve starts as follows:

![qkoch]({{https://blbadger.github.io}}/fractals/koch1.png)

in the first recursion,

![qkoch]({{https://blbadger.github.io}}/fractals/koch2.png)

and after 5 recursive levels, 

![qkoch]({{https://blbadger.github.io}}/fractals/koch5.png)

Let's calculate this curve's similarity dimension: there are 8 pieces that are smaller versions of the whole curve, and these pieces are $1/4$th the length of the whole so therefore

$$
D = \frac{log \; N}{log \; (1/r)} \\
\; \\
D = \frac{log \; 8}{log \; (4)} = 1.5 \\
$$

This curve has a slightly larger dimension than the other Koch curve, which could be interpreted as being that this curve is closer to a surface than the first Koch curve.  Visually, this results in the appearance of a rougher line, one that appears to cover more area than the first.  How long are these curves? Each recursion adds length so just like the space-filling curves, the total length is infinite.  

We can also calculate the dimension of the Cantor set.  There are 2 collections of points that are identical in structure to the entire collection, which we can call L and R.  These collections take up a third of the original interval, and so the dimension of $C$ is

$$
D = \frac{log \; N}{log \; (1/r)} \\
\; \\
D = \frac{log \; 2}{log \; (3)} \approx 0.631
$$

which is somewhere between $0$ and $1$, and this matches the observations that $C$ exhibits properties of both $0$ and $1$ dimensional objects.

Fractals are defined as shapes that have a Hausdorff dimension greater than their topological dimension.  For the shapes presented on this page, Hausdorff and scaling dimensions are equal.  Thus the curves in this section are all fractals, as are the Cantor set and both space-filling Peano curves.  

### More self-similar fractals



The Sierpinski triangle (which will resemble a triforce for those of you who played Zelda) is one of the most distinctive fractals presented in the book. There are two orientations the curve takes, which means that the drawing proceeds as follows:

```python
ls = [60, 60, -60, -60, -60, -60, 60, 60, 0]
def sierpinski_curve(size, recursive_steps, ls):
	if recursive_steps == 0:
		turtle.forward(size)
	else:
		for i in range(len(ls)):
			if i % 2 == 0:
				sierpinski_curve(size, recursive_steps-1, [i for i in ls])
				turtle.left(ls[i])
			else:
				sierpinski_curve(size, recursive_steps-1, [-i for i in ls])
				turtle.left(ls[i])

```
The starting point is

![sierpinski]({{https://blbadger.github.io}}/fractals/sierpinski1.png)

and each line becomes as smaller version of the whole upon the first recursion

![sierpinski]({{https://blbadger.github.io}}/fractals/sierpinski2.png)

![sierpinski]({{https://blbadger.github.io}}/fractals/sierpinski3.png)

And after a few more recursive levels, the following curve is produced:

![sierpinski]({{https://blbadger.github.io}}/fractals/sierpinski.gif)

The following fractal is reminiscent of the appearence of [endocytosis] in cells

```python
def endocytic_curve(size, recursive_steps):
	if recursive_steps > 0:
		for angle in [60, -60, -60]:
			turtle.left(angle)
			endocytic_curve(size, recursive_steps-1)
		turtle.left(60)
	else:
		turtle.forward(size)
```

[endocytic_fractal]({{https://blbadger.github.io}}/fractals/endocytosis001.png)

[endocytic_fractal]({{https://blbadger.github.io}}/fractals/endocytosis002.png)

[endocytic_fractal]({{https://blbadger.github.io}}/fractals/endocytosis003.png)

[endocytic_fractal]({{https://blbadger.github.io}}/fractals/endocytosis004.png)

[endocytic_fractal]({{https://blbadger.github.io}}/fractals/endocytosis.gif)

and here is a modifed version of Sierpinski's triangle that makes fractal snowflakes:

```python
def snowflake_curve(size, recursive_steps):
	if recursive_steps > 0:
		for angle in [60, 60, -60, -60, -60, -60, 60, 60, 0]:
			snowflake_curve(size, recursive_steps-1)
			turtle.left(angle)

	else:
		turtle.forward(size)
```
[snowflake_fractal]({{https://blbadger.github.io}}/fractals/snowflake001.png)

[snowflake_fractal]({{https://blbadger.github.io}}/fractals/snowflake002.png)

[snowflake_fractal]({{https://blbadger.github.io}}/fractals/snowflake003.png)

[snowflake_fractal]({{https://blbadger.github.io}}/fractals/snowflake.gif)

Note that there are smaller snowflakes on the periphery of larger snowflakes: if the recursions were infinite, there would be an infinite number of smaller and smaller snowflakes on these little snowflakes. To save time, the previous image was obtained at a recursive depth of 6.

For more classic fractals and a number of very interesting ideas about fractal geometry in general, see Mandelbrot's [book](https://books.google.com/books/about/The_Fractal_Geometry_of_Nature.html?id=0R2LkE3N7-oC).  

### Fractals in the natural world

Fractals can be thought of as objects that are irregular and do not become more regular as one increases scale, as well as objects that have smaller parts that resemble the whole.  These properties are observed in most objects from nature, and a particularly noteworthy example is in coastlines.  Here is a picture of the Chesapeake Bay taken from a satellite which is found in the Smithsonian museum. 

![chesapeake bay]({{https://blbadger.github.io}}/fractals/chesapeake_bay.png)

Observe how the large bay has many smaller bays that, though not identical in shape, closely resemble the whole bay.  These inlets in turn have smaller inlets and so on past the resolution limit of this image.  This makes the coastline irregular on a large scale but importantly that this irregularity does not diminish with an increase in scale.  

These properties are important because they nullify our attempts to understand such objects by using common measures and techniques.  To be specific, the length of the coastline in the image above is entirely dependent on how high the resolution of the image is: a higher resolution image will yield a larger measurement.  This is not the case for smooth objects that we like to measure, such as the desk I am writing on.  In addition, fractals are non-differentiable: calculus cannot be accurately applied to these objects because at many points they do not have a defined tangent curve. 

