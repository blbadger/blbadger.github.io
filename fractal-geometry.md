## Fractal Geometry

"Clouds are not spheres, mountains are not cones, and lightning does not travel in an straight line..."

Images of dynamical systems, as seen in other pages of [this site](https://blbadger.github.io/), are often described as fractals.  This section explores the meaning of this term, its origins, and deep connections between fractals and nonlinear dynamics and other fields.

### Origin and Cantor's set

The term *Fractal* was chosen by Mandelbrot (after the Latin *Fractus*) to signify irregular (after a sense), fragmented objects.  These often but do not necessarily have a fractional scaling dimension, and the surface of these objects is non-differentiable.  Spectacular examples of fractals such as the Julia and Mandelbrot sets are often brought to mind when one thinks of fractals, but they are far older and richer than these examples alone.  Nearly a century before the word fractal had been invented, the foundations for this branch of math were established and are here roughly detailed.

In the late 19th century Cantor founded set theory, a study of abstract collections of objects and the relations between these collections.  Other pages in this website make use of set theory, and for a good background on the subject see "Naive set theory" by Halmos.  From set theory, we find fascinating conclusions that lay a foundation for fractal geometry, so to understand the latter it is best to examine a few key aspects of the former. 

Surprising results abound in set theory, but one of the most relavant here is that pertaining to measurment.  Firstly, not all infinities are equal: there are as many integers as there are rational numbers (an infinite amount of each) but there are far more real numbers than either.  The elegant diagonal proof for this is worth viewing elsewhere, as it reappears again elsewhere in other forms (in Turing's computability theories, for example). 



```python
from turtle import *
import turtle

for i in range(300):
	turtle.hideturtle()
	turtle.speed(0)
	turtle.delay(0)
	turtle.pensize(4)
	turtle.setup (width=1900, height=1080, startx=0, starty=0)
	turtle.pu()
	turtle.goto(-800, 0)
	turtle.pd()
	def cantor_set(size, recursive_steps):
		if recursive_steps > 0:
			cantor_set(size/3, recursive_steps-1)
			turtle.pu()
			turtle.forward(size)
			turtle.pd()
			cantor_set(size/3, recursive_steps-1)

		else:
			turtle.color('red')
			turtle.forward(size)
			turtle.pu()
			turtle.forward(size)
			turtle.pd()
			turtle.color('blue')
			turtle.forward(size)

	cantor_set(500 * (2**(i/30)), 4 + i // 30)
	turtle_screen = turtle.getscreen()
	turtle_screen.getcanvas().postscript(file="cantor_set{0:03d}.eps".format(i))
	turtle.reset()

```

The `.eps` files generated by this program are vector images, and to make a video conversion to a fixed size .png or .jpg type file is useful.  Fortunately the Python Image Library has the wonderful ability to detect and reformat all kinds of image types!  I used the following program to convert `.eps` to `.png` files:

```python
from PIL import Image
import os

 # insert path here
path = '/home/bbadger/Desktop/' 

files = os.listdir(path)

for i in range(0, len(files)):
	string = str(i)
	while len(string) < 3:
		string = '0' + string
	try:
		eps_image = Image.open('cantor_set' + string + '.eps') # input names here
	except:
		break
	eps_image.load(scale=2)   
	eps_image.save('cantor{0:03d}.png'.format(i)) # output names here
```
After compiling these `.png` images into an mp4 using ffmpeg in bash

```bash
(base) bbadger@bbadger:~$ ffmpeg -f image2 -r 30 -pattern_type glob -i '*.png' cantor_zoom.mp4
```

the video can be viewed and edited.  Here it is as a .gif (ffmpeg can convert directly into gifs simply by changing the extension name to `cantor_zoom.gif`, but these are uncompressed and can be quite large files)

![cantor zoom]({{https://blbadger.github.io}}/fractals/cantor_zoom.gif)

As the number of recursive calls increases, the Cantor set becomes invisible.  This should not come as a surprise, being that it is of measure $0$ as $n \to \infty$, or more precisely the measure at step $n$ is $(\frac{2}{3})^n$.  Thus in order to obtain a viewable map with more recursive steps, vertical lines are used to denote the position of each point in the set.  The following program accomplishes this by drawing alternating red and blue vertical lines at the start of where each set interval (at any given step) begins and so is only accurate with a relatively large value for the starting number of recursions (>4).  A black background is added for clarity, and once again the number of recursive steps increases with scale to maintain resolution.

```python
from turtle import *
import turtle

for i in range(300):
	turtle.hideturtle()
	turtle.bgcolor('black')
	# turtle.color('white')
	turtle.speed(0)
	turtle.delay(0)
	turtle.pensize(0.001)
	turtle.setup (width=1900, height=1080, startx=0, starty=0)

	# fill the background (bgcolor does not save by itself using .postscript())
	turtle.pu()
	turtle.goto(-1100, -600)
	canvas = turtle.getcanvas()
	turtle.fillcolor(turtle.Screen().bgcolor())
	turtle.begin_fill()
	width = 2200
	height = 1200

	turtle.forward(width+2)
	turtle.left(90)
	turtle.forward(height+2)
	turtle.left(90)
	turtle.forward(width+2)
	turtle.left(90)
	turtle.forward(height+2)
	turtle.left(90)
	turtle.end_fill()

	turtle.pu()
	turtle.goto(-910, -540)
	turtle.pd()

	def cantor_set(size, recursive_steps):
		if recursive_steps > 0:
      			# only proceed if not out of canvas bounds
			if turtle.pos()[0] < 1900:
				cantor_set(size/3, recursive_steps-1)
			turtle.pu()
			turtle.forward(size)
			turtle.pd()
			
			# only proceed if not out of canvas bounds
			if turtle.pos()[0] < 1900:
				cantor_set(size/3, recursive_steps-1)

		else:
			turtle.color('blue')
			turtle.left(90)
			turtle.forward(1100)
			turtle.right(180)
			turtle.forward(1100)
			turtle.left(90)
			turtle.pu()
			turtle.forward(size)
			turtle.pd()
			turtle.color('red')
			turtle.left(90)
			turtle.forward(1100)
			turtle.right(180)
			turtle.forward(1100)
			turtle.left(90)

	cantor_set(500*2**(i/60), 6 + i // 90)
	turtle_screen = turtle.getscreen()
	turtle_screen.getcanvas().postscript(file="cantor_set{0:03d}.eps".format(i))
	turtle.reset()
	
```

![cantor zoom]({{https://blbadger.github.io}}/fractals/cantor_zoom_vertical.gif)


### Fractals in the natural world

Fractals can be thought of as objects that are irregular and do not become more regular as one increases scale, as well as objects that have smaller parts that resemble the whole.  These properties are observed in most objects from nature, and a particularly noteworthy example is in coastlines.  Here is a picture of the Chesapeake Bay taken from a sattelite which is found in the Smithsonian museum. 

![chesapeake bay]({{https://blbadger.github.io}}/fractals/chesapeake_bay.png)

Observe how the large bay has many smaller bays that, though not identical in shape, closely resemble the whole bay.  These inlets in turn have smaller inlets and so on past the resolution limit of this image.  This makes the coastline irregular on a large scale but importantly that this irregularity does not diminish with an increase in scale.  

These properties are important because they nullify our attempts to understand such objects by using common measures and techniques.  To be specific, the length of the coastline in the image above is entirely dependent on how high the resolution of the image is: a higher resolution image will yield a larger measurement.  This is not the case for smooth objects that we like to measure, such as the desk I am writing on.  In addition, fractals are non-differentiable: calculus cannot be accurately applied to these objects because at many points they do not have a defined tangent curve. 

